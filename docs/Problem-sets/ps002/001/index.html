<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Exercise 01 # Study a hidden surface determination algorithm such as the painter’s algorithm, binary space partitioning, the Warnock algorithm or ray casting. Introducción # Problema de visiblización # En geometría, la visibilidad es una abstracción matemática de la visibilidad real, que consiste en, dado un conjunto de obstáculos en el espacio euclidiano, se dice que dos puntos en el espacio son visibles entre sí si el segmento de línea que los une, no intersecta ningún obstáculo."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content><meta property="og:description" content="Exercise 01 # Study a hidden surface determination algorithm such as the painter’s algorithm, binary space partitioning, the Warnock algorithm or ray casting. Introducción # Problema de visiblización # En geometría, la visibilidad es una abstracción matemática de la visibilidad real, que consiste en, dado un conjunto de obstáculos en el espacio euclidiano, se dice que dos puntos en el espacio son visibles entre sí si el segmento de línea que los une, no intersecta ningún obstáculo."><meta property="og:type" content="article"><meta property="og:url" content="https://judelgadoc.github.io/visualcomputing/docs/Problem-sets/ps002/001/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2023-06-19T11:01:23-05:00"><title>1st | Showcase</title><link rel=manifest href=/visualcomputing/manifest.json><link rel=icon href=/visualcomputing/favicon.png type=image/x-icon><link rel=stylesheet href=/visualcomputing/book.min.4b35fed0bea034bbc19c89c71e14b73fb9c68cfcc586b9382adfb9b7b103ba06.css integrity="sha256-SzX+0L6gNLvBnInHHhS3P7nGjPzFhrk4Kt+5t7EDugY=" crossorigin=anonymous><script defer src=/visualcomputing/flexsearch.min.js></script>
<script defer src=/visualcomputing/en.search.min.cd1ad44dddd2ee065a837df8d7af49418c2f17d0ce74ddff80aecba7f63a83fd.js integrity="sha256-zRrUTd3S7gZag334169JQYwvF9DOdN3/gK7Lp/Y6g/0=" crossorigin=anonymous></script>
<link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/prism/9000.0.1/themes/prism-okaidia.min.css integrity="sha512-5HvW0a7ihK3ro2KhwEksDHXgIezsTeZybZDIn8d8Y015Ny+t7QWSIjnlCTjFzlK7Klb604HLGjsNqU/i5mJLjQ==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/prism/9000.0.1/plugins/line-numbers/prism-line-numbers.min.css integrity="sha512-3/cdM9qaJ5lBlzRKqwhMw+ZcNCVonz66BO6HgJudG/P1azm9wFrru31SsBa4T4Ew1AOH8HfDXSWS6emWwPl42A==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/9000.0.1/prism.min.js integrity="sha512-UOoJElONeUNzQbbKQbjldDf9MwOHqxNz49NNJJ1d90yp+X9edsHyJoAs6O4K19CZGaIdjI5ohK+O2y5lBTW6uQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/9000.0.1/plugins/line-numbers/prism-line-numbers.min.js integrity="sha512-QTYXYEniHb1m0ZKtSyfpmw40uH9vPfV07vxsv/plIRMEiON4yOp2qoZiv/FTqFIOym4bdQ4+p9RtHaCMC0ApRw==" crossorigin=anonymous referrerpolicy=no-referrer></script><style>.line-numbers-rows>span{display:block;counter-increment:linenumber;line-height:1.5rem}</style></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/visualcomputing/><span>Showcase</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li class=book-section-flat><span>Problem Sets</span><ul><li><input type=checkbox id=section-076859a6cca38d464e24cfb9d51db697 class=toggle>
<label for=section-076859a6cca38d464e24cfb9d51db697 class="flex justify-between"><a role=button>Problem set 1</a></label><ul><li><a href=/visualcomputing/docs/Problem-sets/ps001/001/>1st</a></li><li><a href=/visualcomputing/docs/Problem-sets/ps001/002/>2nd</a></li><li><a href=/visualcomputing/docs/Problem-sets/ps001/004/>4th</a></li><li><a href=/visualcomputing/docs/Problem-sets/ps001/005/>5th</a></li><li><a href=/visualcomputing/docs/Problem-sets/ps001/008/>8th</a></li><li><a href=/visualcomputing/docs/Problem-sets/ps001/video/>Video</a></li></ul></li><li><input type=checkbox id=section-07d68b94071726c941f311623e5cdb70 class=toggle checked>
<label for=section-07d68b94071726c941f311623e5cdb70 class="flex justify-between"><a role=button>Problem set 2</a></label><ul><li><a href=/visualcomputing/docs/Problem-sets/ps002/001/ class=active>1st</a></li><li><a href=/visualcomputing/docs/Problem-sets/ps002/002/>2nd</a></li><li><a href=/visualcomputing/docs/Problem-sets/ps002/003/>3rd</a></li><li><a href=/visualcomputing/docs/Problem-sets/ps002/004/>4th</a></li><li><a href=/visualcomputing/docs/Problem-sets/ps002/005/>5th</a></li><li><a href=/visualcomputing/docs/Problem-sets/ps002/006/>6th</a></li><li><a href=/visualcomputing/docs/Problem-sets/ps002/007/>7th</a></li><li><a href=/visualcomputing/docs/Problem-sets/ps002/008/>8th</a></li><li><a href=/visualcomputing/docs/Problem-sets/ps002/image-processing/>Procesamiento de imágenes</a></li></ul></li></ul></li></ul><ul><li><a href=/visualcomputing/posts/>Integrantes</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/visualcomputing/svg/menu.svg class=book-icon alt=Menu></label>
<strong>1st</strong>
<label for=toc-control><img src=/visualcomputing/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#exercise-01>Exercise 01</a><ul><li><a href=#introducción>Introducción</a><ul><li><a href=#problema-de-visiblización>Problema de visiblización</a></li><li><a href=#determinación-de-superficies-ocultas-hidden-surface-determination>Determinación de superficies ocultas (Hidden-surface determination)</a></li><li><a href=#algoritmo-de-determinación-de-superficies>Algoritmo de determinación de superficies</a></li></ul></li><li><a href=#antecedentes>Antecedentes</a></li><li><a href=#consideraciones>Consideraciones</a></li><li><a href=#algoritmo-del-pintor>Algoritmo del pintor</a></li><li><a href=#pseudocódigo>Pseudocódigo</a><ul><li></li></ul></li><li><a href=#principal-limitación>Principal limitación</a></li><li><a href=#conclusión>Conclusión</a></li><li><a href=#referencias>Referencias</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=exercise-01>Exercise 01
<a class=anchor href=#exercise-01>#</a></h1><blockquote class="book-hint info">Study a hidden surface determination algorithm such as the <a href=https://en.wikipedia.org/wiki/Painter%27s_algorithm>painter’s algorithm</a>, <a href=https://en.wikipedia.org/wiki/Binary_space_partitioning>binary space partitioning</a>, the <a href=https://en.wikipedia.org/wiki/Binary_space_partitioning>Warnock algorithm</a> or <a href=https://en.wikipedia.org/wiki/Ray_casting>ray casting</a>.</blockquote><h2 id=introducción>Introducción
<a class=anchor href=#introducci%c3%b3n>#</a></h2><h3 id=problema-de-visiblización>Problema de visiblización
<a class=anchor href=#problema-de-visiblizaci%c3%b3n>#</a></h3><p>En geometría, la visibilidad es una abstracción matemática de la visibilidad real, que consiste en, dado un conjunto de obstáculos en el espacio euclidiano, se dice que dos puntos en el espacio son visibles entre sí si el segmento de línea que los une, no intersecta ningún obstáculo.</p><p>El concepto anterior es una simplificación a cómo funcionan los aces de luz reales, los cuales poseen una trayectoria ligeramente curva.</p><h3 id=determinación-de-superficies-ocultas-hidden-surface-determination>Determinación de superficies ocultas (Hidden-surface determination)
<a class=anchor href=#determinaci%c3%b3n-de-superficies-ocultas-hidden-surface-determination>#</a></h3><p>En el área de visualización de gráficos por computadora, la determinación de superficies ocultas es el proceso de identificar qué superficies y partes de superficies pueden ser vistas desde determinado ángulo de visualización desde la perspectiva de un observador.</p><h3 id=algoritmo-de-determinación-de-superficies>Algoritmo de determinación de superficies
<a class=anchor href=#algoritmo-de-determinaci%c3%b3n-de-superficies>#</a></h3><p>Este tipo de algoritmos corresponden a una solución al problema de visibilidad comentado anteriormente, y se enfoca en determinar las superficies ocultas necesarias para que una escena pueda ser representada correctamente, de modo que no se puedan ver las características ocultas detrás del propio modelo, permitiendo que sólo se vea la porción lógicamente visible por el observador.</p><h2 id=antecedentes>Antecedentes
<a class=anchor href=#antecedentes>#</a></h2><p>La renderización en sí, posee dos objetivos distintos pero relacionados, en primer lugar, el determinar que superficies no deberían ser visibles para el usuario, dado que, por ejemplo, se encuentren detrás de otros objetos que si deben ser visibles, por otro lado, un motor de renderizado debe poder trabajar con escenarios bastante grandes sin perder su velocidad, la optimización de este proceso se basa en garantizar el uso de la menor cantidad de recursos posibles para renderizar superficies que no se mostrarán al usuario.</p><p>Todos los objetos del escenario deben ser analizados por un algoritmo óptimo, que sea capaz de decidir, en el menor tiempo posible, aquellos elementos que deben mostrarse y aquellos que no.</p><p>Existen muchas técnicas para la determinación de superficies ocultas, el ejercicio propuesto solicita profundizar en una en específico, en el presente informe, nos enfocaremos en el Algoritmo del Pintor (painter’s algorithm).</p><h2 id=consideraciones>Consideraciones
<a class=anchor href=#consideraciones>#</a></h2><p>Aunque nos centraremos en el Algoritmo del Pintor, no está de más darle un pequeño repaso a las otras 3 técnicas mencionadas en el ejercicio.</p><p>Según Wikipedia,</p><p><strong>Particionado Binario de Espacio (BSP)</strong>, divide una escena a lo largo de planos correspondientes a los límites de los polígonos. La subdivisión se construye de tal manera que proporciona un ordenamiento de profundidad inequívoco desde cualquier punto de la escena cuando se recorre el árbol BSP. La desventaja aquí es que el árbol BSP se crea mediante un proceso previo costoso. Esto significa que es menos adecuado para escenas que consisten en geometría dinámica. La ventaja es que los datos están preordenados y libres de errores.</p><p><img src=/visualcomputing/assets/ps002_images/Binary_space_partition.png alt="Texto alternativo de la imagen"></p><p><strong>Trazado de rayos (Ray Tracing)</strong>, intenta modelar la trayectoria de los rayos de luz hacia un punto de la escena desde el punto de vista del observador. Aunque no es un algoritmo de eliminación de superficies como tal, resuelve implícitamente el problema de eliminación de superficies ocultas al encontrar la superficie más cercana a lo largo de cada rayo.</p><p><img src=/visualcomputing/assets/ps002_images/Ray_trace_diagram.svg.png alt="Texto alternativo de la imagen"></p><p><strong>Algoritmo de Warnock</strong>, divide la pantalla en áreas más pequeñas y ordena los triángulos dentro de ellas. Si hay ambigueddad (es decir, si los polígonos se superponen en términos de profundidad dentro de estas áreas), se realiza un subdivisión adicional. En última instancia, la subdivisión puede llegar hasta el nivel de píxel.</p><p><img src=/visualcomputing/assets/ps002_images/800px-Warnock_algorithm.svg.png alt="Texto alternativo de la imagen"></p><h2 id=algoritmo-del-pintor>Algoritmo del pintor
<a class=anchor href=#algoritmo-del-pintor>#</a></h2><p>El funcionamiento del algoritmo es simple, el algoritmo del pintor crea imágenes ordenando los polígonos dentro de la imagen en función de su profundidad, colocando cada polígono en orden desde el objeto más lejano hasta el más cercano.</p><p>El nombre &ldquo;algoritmo del pintor&rdquo; hace referencia a la técnica utilizada por muchos pintores, la cual consiste en ir pintando las partes distantes de una escena antes que las partes más cercanas, cubriendo en el proceso, algunas áreas de las partes distantes.</p><p>La explicación anterior resume el proceso con el que opera el algoritmo del pintro, ordena todos los polígonos de una escena según su profundidad y luego los pinta en ese orden, desde el más lejano al más cercano, el algoritmo pintará sobre las partes que normalmente no son visibles, resolviendo así el problema de la visibilidad.</p><p><strong>Demostración de funcionamiento.</strong></p><iframe src=/visualcomputing/assets/ps002_images/Genesis_fractal_landscape_software_(Commodore_Amiga).webm.720p.vp9.webm width=640 height=360></iframe><h2 id=pseudocódigo>Pseudocódigo
<a class=anchor href=#pseudoc%c3%b3digo>#</a></h2><pre tabindex=0><code>sort polygons by depth
for each polygon p:
    for each pixel that p covers:
        paint p.color on pixel
</code></pre><h4 id=complejidad-del-algoritmo>Complejidad del algoritmo
<a class=anchor href=#complejidad-del-algoritmo>#</a></h4><p>Depende del algoritmo de ordenación utilizado para ordenar los polígonos, suponiendo el uso del algoritmo de ordenamiento más óptimo, el algoritmo del pintor tiene una complejidad, en el peor de los casos, de <strong>O(n log n + m*n)</strong>, donde <strong>n</strong> es el número de polígonos y <strong>m</strong> es el número de píxeles que se deben rellenar.</p><h2 id=principal-limitación>Principal limitación
<a class=anchor href=#principal-limitaci%c3%b3n>#</a></h2><p>La superposición cíclica, caso que se muestra en la siguiente imagen, en la que 3 polígonos se superponen entre sí en diferentes espacios, haciendo imposible el proceso de ordenamiento.</p><p><img src=/visualcomputing/assets/ps002_images/800px-Painters_problem.svg.png alt="Texto alternativo de la imagen"></p><p><strong>Nota:</strong> Los polígonos generalmente se representan cómo triangulos, aunque en la imagen anterior se muestren figuras rectangulares, el principio es el mismo.</p><p>La renderización de esta figura sería imposible con el algoritmo del pintor, puesto que, de cualquier forma, la renderización de los 3 polígonos se llevará a cabo de forma secuencial, por lo que inevitablemente, alguno de ellos quedará tapado por el resto.</p><p>Solucionar este inconveniente requiere el uso de otro tipo de métodos ajenos a la idea principal del algoritmo del pintor.</p><h2 id=conclusión>Conclusión
<a class=anchor href=#conclusi%c3%b3n>#</a></h2><p>El algoritmo del pintor corresponde al método más simple de resolver el problema de la visualización, es un algoritmo sencillo y confiable, que no tiende a generar demasiados errores, pero que consume una cantidad enorme de tiempo y recursos sin importar el nivel de optimización que se intente, además de presentar el inconveniente de la superposición cíclica.</p><p>Este método, por lo intuitivo y sencillo, fue la solución idónea en los primeros años de existencia de los gráficos computacionales, cuando el espacio en memoria era bastante limitado, no obstante, en la actualidad, su uso, debe desaconcejarse, dada la existencia de mejores técnicas que aprovechan el potencial de la tecnología vigente.</p><h2 id=referencias>Referencias
<a class=anchor href=#referencias>#</a></h2><ul><li>Wikipedia contributors. (2023). Visibility (geometry). Wikipedia. <a href=https://en.wikipedia.org/wiki/Visibility_%28geometry%29>https://en.wikipedia.org/wiki/Visibility_(geometry)</a></li><li>Wikipedia contributors. (2023b). Binary space partitioning. Wikipedia. <a href=https://en.wikipedia.org/wiki/Binary_space_partitioning#/media/File:Binary_space_partition.png>https://en.wikipedia.org/wiki/Binary_space_partitioning#/media/File:Binary_space_partition.png</a></li><li>Wikipedia contributors. (2023b). Ray tracing (graphics). Wikipedia. <a href=https://en.wikipedia.org/wiki/Ray_tracing_%28graphics%29#/media/File:Ray_trace_diagram.svg>https://en.wikipedia.org/wiki/Ray_tracing_(graphics)#/media/File:Ray_trace_diagram.svg</a></li><li>Wikipedia contributors. (2022). Warnock algorithm. Wikipedia. <a href=https://en.wikipedia.org/wiki/Warnock_algorithm#/media/File:Warnock_algorithm.svg>https://en.wikipedia.org/wiki/Warnock_algorithm#/media/File:Warnock_algorithm.svg</a></li><li>Wikipedia contributors. (2022a). Hidden-surface determination. Wikipedia. <a href=https://en.wikipedia.org/wiki/Hidden-surface_determination>https://en.wikipedia.org/wiki/Hidden-surface_determination</a></li><li><a href=https://en.wikipedia.org/wiki/Painter%27s_algorithm>https://en.wikipedia.org/wiki/Painter%27s_algorithm</a></li></ul></article><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/9000.0.1/plugins/file-highlight/prism-file-highlight.min.js integrity="sha512-FWNmm0IyLo0UvBFHCvBmbxEN5M9hELGsEvI6C+77AloPqCUnwGfi7mTJWun6eov18cs8gB6Svh00iwUVqtNQjQ==" crossorigin=anonymous referrerpolicy=no-referrer></script><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/judelgadoc/visualcomputing/commit/dac04b334a33c2d0b40b1d1f494d96ec2d2f6817 title='Last modified by Daniel Zúñiga | June 19, 2023' target=_blank rel=noopener><img src=/visualcomputing/svg/calendar.svg class=book-icon alt=Calendar>
<span>June 19, 2023</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#exercise-01>Exercise 01</a><ul><li><a href=#introducción>Introducción</a><ul><li><a href=#problema-de-visiblización>Problema de visiblización</a></li><li><a href=#determinación-de-superficies-ocultas-hidden-surface-determination>Determinación de superficies ocultas (Hidden-surface determination)</a></li><li><a href=#algoritmo-de-determinación-de-superficies>Algoritmo de determinación de superficies</a></li></ul></li><li><a href=#antecedentes>Antecedentes</a></li><li><a href=#consideraciones>Consideraciones</a></li><li><a href=#algoritmo-del-pintor>Algoritmo del pintor</a></li><li><a href=#pseudocódigo>Pseudocódigo</a><ul><li></li></ul></li><li><a href=#principal-limitación>Principal limitación</a></li><li><a href=#conclusión>Conclusión</a></li><li><a href=#referencias>Referencias</a></li></ul></li></ul></nav></div></aside></main></body></html>